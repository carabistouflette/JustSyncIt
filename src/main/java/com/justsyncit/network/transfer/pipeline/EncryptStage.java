/*
 * JustSyncIt - Backup solution
 * Copyright (C) 2023 JustSyncIt Team
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

package com.justsyncit.network.transfer.pipeline;

import com.justsyncit.network.encryption.EncryptionException;
import com.justsyncit.network.encryption.EncryptionService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

/**
 * Pipeline stage that encrypts chunk data using AES-256-GCM.
 * 
 * <p>
 * This stage should be placed after compression in the pipeline.
 * Each chunk gets a unique IV for security.
 * 
 * <p>
 * Uses the transfer ID as associated data for AEAD binding,
 * ensuring chunks cannot be replayed across different transfers.
 */
public final class EncryptStage implements PipelineStage<ChunkTask, ChunkTask> {

    private static final Logger logger = LoggerFactory.getLogger(EncryptStage.class);

    private final ExecutorService executor;
    private final EncryptionService encryptionService;
    private final byte[] encryptionKey;
    private final boolean enabled;
    private final String keyAlias;

    /**
     * Creates an encryption stage.
     *
     * @param executor          the executor for async operations
     * @param encryptionService the encryption service to use
     * @param encryptionKey     the encryption key (256-bit for AES-256)
     * @param enabled           whether encryption is enabled
     * @param keyAlias          identifier for the key (for metadata)
     */
    public EncryptStage(
            ExecutorService executor,
            EncryptionService encryptionService,
            byte[] encryptionKey,
            boolean enabled,
            String keyAlias) {
        this.executor = executor;
        this.encryptionService = encryptionService;
        this.encryptionKey = encryptionKey != null ? encryptionKey.clone() : null;
        this.enabled = enabled;
        this.keyAlias = keyAlias;
    }

    @Override
    public CompletableFuture<ChunkTask> process(ChunkTask task) {
        if (!enabled || encryptionService == null || encryptionKey == null) {
            // Passthrough if disabled
            return CompletableFuture.completedFuture(task);
        }

        return CompletableFuture.supplyAsync(() -> {
            try {
                // Get data to encrypt (processed data from previous stage, or raw)
                byte[] plaintext = task.getProcessedData();
                if (plaintext == null) {
                    plaintext = task.getRawData();
                }

                if (plaintext == null || plaintext.length == 0) {
                    logger.warn("No data to encrypt for chunk at offset {}", task.getOffset());
                    return task;
                }

                // Use transfer ID as associated data for AEAD binding
                byte[] associatedData = task.getTransferId().getBytes(
                        java.nio.charset.StandardCharsets.UTF_8);

                // Encrypt with unique IV (generated by encryption service)
                byte[] ciphertext = encryptionService.encrypt(
                        plaintext, encryptionKey, associatedData);

                // Update task with encrypted data
                task.setProcessedData(ciphertext);
                task.setEncrypted(true);
                task.setKeyAlias(keyAlias);

                logger.debug("Encrypted chunk at offset {}, size: {} -> {}",
                        task.getOffset(), plaintext.length, ciphertext.length);

                return task;

            } catch (EncryptionException e) {
                logger.error("Encryption failed for chunk at offset {}", task.getOffset(), e);
                throw new RuntimeException("Encryption failed", e);
            }
        }, executor);
    }

    @Override
    public String getName() {
        return "EncryptStage";
    }

    @Override
    public void shutdown() {
        // Clear encryption key from memory (best effort)
        if (encryptionKey != null) {
            java.util.Arrays.fill(encryptionKey, (byte) 0);
        }
    }
}
